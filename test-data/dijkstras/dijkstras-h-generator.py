import random

# ----- Configuration -----
GRAPH_SIZE = 50  # fixed number of nodes per graph
OVERHEAD = 96    # 3 ints (size, source, destination), assumed 4 bytes each
STRUCT_SIZE = GRAPH_SIZE * GRAPH_SIZE + OVERHEAD  # size in bytes per GraphData instance
TARGET_TOTAL_BYTES = 200 * 1024  # target of ~200 KB
# num_graphs = TARGET_TOTAL_BYTES // STRUCT_SIZE
num_graphs = 6 
if num_graphs < 1:
    num_graphs = 1  # ensure we generate at least one graph

# For extra edges: adjust probability (0.1 yields sparse extra edges)
EDGE_PROBABILITY = 0.1

print(f"Generating {num_graphs} graphs of {GRAPH_SIZE} nodes each (~{num_graphs * STRUCT_SIZE} bytes total).")

# ----- Graph Generation -----
def generate_graph():
    n = GRAPH_SIZE  # fixed to 50 nodes
    # Initialize a 50x50 matrix with -1 (which represents infinity)
    matrix = [[-1 for _ in range(n)] for _ in range(n)]
    
    # Create a spanning tree to guarantee connectivity
    nodes = list(range(n))
    random.shuffle(nodes)
    for i in range(1, n):
        parent = random.choice(nodes[:i])
        u = nodes[i]
        v = parent
        weight = min(random.randint(1, 127), 127)
        matrix[u][v] = weight
        matrix[v][u] = weight

    # Add extra random edges
    for i in range(n):
        for j in range(i+1, n):
            if matrix[i][j] == -1 and random.random() < EDGE_PROBABILITY:
                weight = random.randint(1, 127)
                matrix[i][j] = weight
                matrix[j][i] = weight

    # Pick distinct source and destination nodes
    source = random.randint(0, n-1)
    destination = random.randint(0, n-1)
    while destination == source:
        destination = random.randint(0, n-1)
    
    return {
        "size": n,
        "source": source,
        "destination": destination,
        "matrix": matrix
    }

# ----- Generate the graphs -----
graphs = [generate_graph() for _ in range(num_graphs)]

# ----- Write the C header file -----
header_filename = "test_data.h"
with open(header_filename, "w") as f:
    f.write("#ifndef DIJKSTRAS_TEST_DATA_H\n")
    f.write("#define DIJKSTRAS_TEST_DATA_H\n\n")
    f.write("// Dijkstra's test data generated by a Python script\n")
    f.write("// Each graph is a 50-node graph with a 50x50 adjacency matrix.\n")
    f.write("// -1 represents infinity. The spanning tree guarantees connectivity, so there is always a path\n")
    f.write("// from source to destination (i.e. no singletons).\n\n")
    f.write("#define GRAPH_SIZE 50\n\n")
    f.write("typedef struct {\n")
    f.write("    int size;         // number of nodes in the graph\n")
    f.write("    int source;       // source node for Dijkstra's algorithm\n")
    f.write("    int destination;  // destination node\n")
    f.write("    int graph[GRAPH_SIZE][GRAPH_SIZE]; // adjacency matrix\n")
    f.write("} GraphData;\n\n")
    
    f.write(f"static const GraphData dijkstrasTestDataArray[{num_graphs}] = {{\n")
    # Write each graph
    for idx, g in enumerate(graphs):
        f.write("    {\n")
        f.write(f"        .size = {g['size']},\n")
        f.write(f"        .source = {g['source']},\n")
        f.write(f"        .destination = {g['destination']},\n")
        f.write("        .graph = {\n")
        for i, row in enumerate(g["matrix"]):
            row_str = ", ".join(str(x) for x in row)
            if i < len(g["matrix"]) - 1:
                f.write("            { " + row_str + " },\n")
            else:
                f.write("            { " + row_str + " }\n")
        f.write("        }\n")
        if idx < num_graphs - 1:
            f.write("    },\n")
        else:
            f.write("    }\n")
    f.write("};\n\n")
    f.write(f"static const int dijkstrasTestDataArraySize = {num_graphs};\n\n")
    f.write("#endif // DIJKSTRAS_TEST_DATA_H\n")

print(f"Header file '{header_filename}' generated successfully.")

# ----- Write the Zig file -----
zig_filename = "test_data.zig"
with open(zig_filename, "w") as f:
    f.write("// Dijkstra's test data generated by a Python script\n")
    f.write("const std = @import(\"std\");\n\n")
    f.write("pub const GRAPH_SIZE = 50;\n\n")
    f.write("pub const GraphData = struct {\n")
    f.write("    size: i32,\n")
    f.write("    source: i32,\n")
    f.write("    destination: i32,\n")
    f.write("    graph: [GRAPH_SIZE][GRAPH_SIZE]i32,\n")
    f.write("};\n\n")
    f.write("pub const dijkstrasTestDataArray = [_]GraphData{\n")
    # Write each graph entry
    for g in graphs:
        f.write("    GraphData{\n")
        f.write(f"        .size = {g['size']},\n")
        f.write(f"        .source = {g['source']},\n")
        f.write(f"        .destination = {g['destination']},\n")
        f.write("        .graph = [GRAPH_SIZE][GRAPH_SIZE]i32{\n")
        for row in g["matrix"]:
            row_str = ", ".join(str(x) for x in row)
            f.write("            { " + row_str + " },\n")
        f.write("        },\n")
        f.write("    },\n")
    f.write("};\n\n")
    f.write(f"pub const dijkstrasTestDataArraySize = {num_graphs};\n")

print(f"Zig file '{zig_filename}' generated successfully.")
